<!doctype html>
<html lang="vi">
<head>
  <link rel="icon" type="image/png" href="fa.png">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Block Deluxe ‚Äî T√°o B·∫Øc Vi·ªát</title>
<link rel="icon" href="fa.png" type="image/png">
<style>
:root{
  --bg:#071421; --panel:#081826; --accent:#ffd66b; --muted:#9fb0cc;
  --card:#071827;
}
html,body{height:100%;margin:0;background:var(--bg);color:#e6eef8;font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
.app{min-height:100vh;display:flex;flex-direction:column;align-items:stretch;gap:10px;padding:12px;box-sizing:border-box}
.header{display:flex;flex-direction:row;align-items:center;justify-content:space-between;padding:10px 12px;background:linear-gradient(180deg,var(--card),#05121a);border-radius:12px}
.player{display:flex;flex-direction:column;gap:6px}
.player .title{font-weight:800;font-size:16px}
.stats{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
.stat{font-size:13px;color:var(--muted)}
.stat strong{color:#fff;margin-left:6px}
.controls{display:flex;gap:8px;align-items:center}
.btn{background:var(--accent);border:none;padding:8px 12px;border-radius:8px;color:#081018;font-weight:700;cursor:pointer;touch-action:none}
.smallBtn{background:#9fb0cc;padding:6px 8px;border-radius:8px;color:#081018;font-weight:700}
.container{display:flex;flex-direction:column;align-items:stretch;gap:10px;flex:1;justify-content:center}
.gameWrap{display:flex;flex-direction:column;align-items:center;gap:8px}
.canvas-wrap{background:linear-gradient(180deg,#06121a,#051018);padding:10px;border-radius:12px;display:flex;align-items:center;justify-content:center;box-shadow:0 10px 30px rgba(0,0,0,0.5)}
canvas{background:#06121a;border-radius:8px;display:block;touch-action:none}
.piecesWrap{display:flex;gap:12px;align-items:center;justify-content:center;padding:10px;flex-wrap:nowrap}
.big-slot{width:110px;height:110px;background:#071722;border-radius:12px;display:flex;align-items:center;justify-content:center;box-shadow:inset 0 2px 6px rgba(0,0,0,0.4);touch-action:none;user-select:none}
.footer{padding:10px;border-radius:12px;background:linear-gradient(180deg,#071827,#04101a);text-align:center;color:var(--muted);font-size:13px}
.toast-wrap{position:fixed;left:50%;transform:translateX(-50%);top:18px;pointer-events:none;z-index:60}
.toast{background:rgba(0,0,0,0.55);color:#fff;padding:8px 12px;border-radius:8px;margin-top:8px;opacity:0;transform:translateY(-8px) scale(.98);transition:all .28s cubic-bezier(.2,.9,.2,1)}
.toast.show{opacity:1;transform:translateY(0) scale(1)}
#nameModal{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.6);z-index:120;visibility:hidden}
#nameModal.show{visibility:visible}
.modalCard{background:var(--card);padding:18px;border-radius:10px;min-width:280px}
.input{width:100%;padding:8px;border-radius:8px;border:1px solid #224;outline:none;background:#0b1a24;color:#e6eef8}
.smallNote{font-size:12px;color:var(--muted);margin-top:8px}
.crown{font-size:18px;margin-left:6px}
.continueBtn{position:fixed;right:16px;bottom:16px;background:#ffd66b;color:#081018;padding:10px 14px;border-radius:12px;font-weight:700;box-shadow:0 8px 20px rgba(0,0,0,0.5);display:none;z-index:200}
@media (min-width:900px){
  .app{max-width:980px;margin:18px auto}
  .big-slot{width:120px;height:120px}
}
</style>
</head>
<body>
  <audio id="bgm" src="bc.mp3" loop autoplay></audio>
<div class="app">
  <!-- header / player -->
  <div class="header">
    <div class="player">
      <div class="title">Block Deluxe</div>
      <div class="stats">
        <div class="stat">Player: <strong id="playerName">Guest</strong></div>
        <div class="stat">Score: <strong id="score">0</strong></div>
        <div class="stat">High: <strong id="high">0</strong><span id="crown" class="crown" style="display:none"> üëë</span></div>
      </div>
    </div>
    <div class="controls">
      <button id="reset" class="btn">Reset</button>
      <button id="mute" class="smallBtn">Sound</button>
    </div>
  </div>

  <!-- main game column -->
  <div class="container">
    <div class="gameWrap">
      <div class="canvas-wrap" id="canvasWrap">
        <canvas id="game" width="740" height="740" aria-label="Block Deluxe board"></canvas>
      </div>

      <!-- big piece slots (drag from here) -->
      <div class="piecesWrap" id="piecesWrap">
        <!-- JS will create 3 .big-slot elements, each contains a small canvas -->
      </div>
    </div>
  </div>

  <!-- footer -->
  <div class="footer">¬© T√°o B·∫Øc Vi·ªát Team ‚Äî Block Deluxe</div>
</div>

<div class="toast-wrap" id="toastWrap"></div>
<button id="continueBtn" class="continueBtn">Ti·∫øp t·ª•c (m·∫•t 1 l∆∞·ª£t)</button>

<!-- Name modal -->
<div id="nameModal"><div class="modalCard">
  <div style="font-weight:700;margin-bottom:8px">Xin ch√†o! Nh·∫≠p t√™n ƒë·ªÉ b·∫Øt ƒë·∫ßu</div>
  <input id="nameInput" class="input" placeholder="T√™n c·ªßa b·∫°n..." />
  <div style="margin-top:10px;display:flex;gap:8px">
    <button id="nameSave" class="btn">B·∫Øt ƒë·∫ßu</button>
    <button id="skipName" class="smallBtn">B·ªè qua</button>
  </div>
  <div class="smallNote">T√™n s·∫Ω ƒë∆∞·ª£c l∆∞u tr√™n tr√¨nh duy·ªát (localStorage).</div>
</div></div>

<!-- background music file (bc.mp3) -->
<audio id="bgMusic" src="bc.mp3" loop preload="auto"></audio>

<script>
/*
  Block Deluxe ‚Äî Mobile-optimized vertical layout version
  - Drag from big-slot only (3 slots)
  - Double-click on slot to rotate clockwise
  - Double-click while dragging rotates
  - Touch support via Pointer Events
  - Score by placed cells + combo bonuses; particles & rainbow; 5 fake losses
  - Name prompt saved to localStorage; highscore saved with crown
  - Uses WebAudio for SFX; bgMusic plays on first user interaction
*/

(() => {
  // Config
  const GRID = 9, CELL = 56, OFFSET = 10;
  const BOARD_W = GRID * CELL, BOARD_H = GRID * CELL;
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha: false });
  const canvasWrap = document.getElementById('canvasWrap');
  const piecesWrap = document.getElementById('piecesWrap');
  const scoreEl = document.getElementById('score');
  const highEl = document.getElementById('high');
  const resetBtn = document.getElementById('reset');
  const muteBtn = document.getElementById('mute');
  const toastWrap = document.getElementById('toastWrap');
  const playerNameEl = document.getElementById('playerName');
  const livesEl = document.getElementById('lives') || null;
  const comboEl = document.getElementById('combo') || null;
  const bagCountEl = document.getElementById('bagCount') || null;
  const crownEl = document.getElementById('crown');
  const continueBtn = document.getElementById('continueBtn');
  const bgMusic = document.getElementById('bgMusic');

  // Responsive canvas sizing (fit available width on mobile)
  function adjustCanvasSize(){
    // canvas area width based on container
    const available = Math.min(window.innerWidth - 28, 760);
    const size = Math.min(available, window.innerHeight - 240); // leave space for header/footer
    canvas.style.width = size + 'px';
    canvas.style.height = size + 'px';
    const dpr = Math.min(window.devicePixelRatio || 1, 2);
    canvas.width = Math.round(size * dpr);
    canvas.height = Math.round(size * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  adjustCanvasSize();
  window.addEventListener('resize', adjustCanvasSize);

  // Palettes & shapes (with stairs etc.)
  const PALETTE = ['#FF6B6B','#FF9F43','#FFD66B','#9AE66A','#6BCBFF','#6B8CFF','#C27BFF','#9bf','#f9b','#7ff'];
  const SHAPES = [
    [[1,1,1,1]],           // I4
    [[1,1,1]],             // 3
    [[1,1]],               // 2
    [[1,1],[1,1]],         // O
    [[1,0],[1,0],[1,1]],   // L tall
    [[0,1],[0,1],[1,1]],   // J tall
    [[1,1,1],[1,0,0]],     // L
    [[1,1,1],[0,0,1]],     // J
    [[1,1,1],[0,1,0]],     // T
    [[1,1,0],[0,1,1]],     // Z
    [[0,1,1],[1,1,0]],     // S
    [[1,0],[1,1]],         // small corner
    [[0,1],[1,1]],         // other corner
    [[1,0,1],[1,1,1]],     // more complex
    [[1,1,0],[0,1,0],[0,1,1]], // step-like
    [[1,0],[1,0],[1,0],[1,0]], // I vertical 4
    [[1,1,0],[0,1,1]],     // stair (2-step)
    [[1,1,1,1,1]],         // 5-long (rare)
    [[1,1,1],[1,1,1]]      // 3x2 block
  ];

  // State
  let grid = [];
  let pieces = []; // 3 waiting pieces
  let bag = [];
  let score = 0, highScore = 0, combo = 0;
  let dragging = null;
  let particles = [];
  let anims = [];
  let gameOver = false;
  let fakeLossesRemaining = parseInt(localStorage.getItem('bb_fake_losses') || '5', 10);
  let undoCount = 1;
  let historyStack = [];
  let isMuted = false;

  // WebAudio
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  const audioCtx = new AudioCtx();
  const master = audioCtx.createGain(); master.gain.value = 1; master.connect(audioCtx.destination);

  function makeTone(freq, type='sine', dur=0.18, vol=0.08){
    if(isMuted) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type; o.frequency.value = freq;
    g.gain.value = 0.0001;
    o.connect(g); g.connect(master);
    const now = audioCtx.currentTime;
    g.gain.linearRampToValueAtTime(vol, now+0.006);
    o.start(now);
    g.gain.exponentialRampToValueAtTime(0.0001, now+dur);
    o.stop(now+dur+0.02);
  }
  function playPlace(){ makeTone(880,'sine',0.16,0.12); }
  function playClear(){ const now = audioCtx.currentTime; [420,660,880].forEach((f,i)=>{ const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='sawtooth'; o.frequency.value=f; g.gain.value=0.0001; o.connect(g); g.connect(master); g.gain.linearRampToValueAtTime(0.16/(i+1), now+0.002); g.gain.exponentialRampToValueAtTime(0.0001, now+0.6); o.start(now); o.stop(now+0.6); }); }
  function playFail(){ makeTone(130,'sine',0.5,0.12); }
  function playWin(){ makeTone(1200,'triangle',0.38,0.14); makeTone(1700,'sine',0.32,0.08); }

  // Helpers
  function deepClone(v){ return JSON.parse(JSON.stringify(v)); }
  function randColor(){ return PALETTE[Math.floor(Math.random()*PALETTE.length)]; }
  function rotateMatrix(m){ const R=m.length, C=m[0].length; const out=Array(C).fill().map(()=>Array(R).fill(0)); for(let r=0;r<R;r++) for(let c=0;c<C;c++) out[c][R-1-r]=m[r][c]; return out; }

  // Grid init
  function resetGrid(){ grid = Array(GRID).fill().map(()=>Array(GRID).fill(0)); }
  resetGrid();

  // Bag
  function refillBag(){ bag = []; for(let i=0;i<SHAPES.length;i++) bag.push(i); for(let i=bag.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [bag[i],bag[j]]=[bag[j],bag[i]]; } updateBagCount(); }
  function nextFromBag(){ if(bag.length===0) refillBag(); const idx = bag.pop(); updateBagCount(); return { shape: deepClone(SHAPES[idx]), color: randColor() }; }
  function updateBagCount(){ if(bagCountEl) bagCountEl.textContent = bag.length; }

  // Ensure at least one valid placement when generating pieces
  function generatePieces(){
    let attempts=0;
    do {
      pieces = [];
      for(let i=0;i<3;i++){
        pieces.push(Object.assign(nextFromBag(), {
          x: 0, y:0, spawnX:0, spawnY:0
        }));
      }
      attempts++;
      if(attempts>18) break;
    } while(!hasAnyMoveForPieces(pieces));
    renderPiecesSlots();
  }

  // Drawing board & pieces
  function draw(){
    // clear
    ctx.fillStyle = '#06121a';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // compute scale because canvas may be resized
    const displaySize = parseFloat(canvas.style.width) || canvas.width;
    const scale = (parseFloat(canvas.style.width) || canvas.width) / (BOARD_W + OFFSET*2 + 120);
    // Instead of scaling approach, we will compute cell size based on canvas pixel width to keep board square
    const pxSize = Math.min(canvas.width / (GRID), canvas.height / (GRID));
    const cell = pxSize; // pixel per cell on canvas coordinate space (we already set transform with DPR)
    // board origin
    const totalBoardPx = cell * GRID;
    const bx = (canvas.width / (window.devicePixelRatio||1) - totalBoardPx) / 2;
    const by = (canvas.height / (window.devicePixelRatio||1) - totalBoardPx) / 2;

    // draw cells and detect empty
    let hasAny=false;
    for(let r=0;r<GRID;r++){
      for(let c=0;c<GRID;c++){
        const x = bx + c*cell, y = by + r*cell;
        if(grid[r][c]){ hasAny=true; ctx.fillStyle = grid[r][c]; }
        else ctx.fillStyle = 'rgba(255,255,255,0.02)';
        roundRectFill(x+4, y+4, cell-8, cell-8, 6);
        ctx.strokeStyle = 'rgba(0,0,0,0.12)'; ctx.strokeRect(x+4,y+4,cell-8,cell-8);
      }
    }

    // rainbow when empty: each cell own hue (top->down, left->right)
    if(!hasAny){
      for(let r=0;r<GRID;r++){
        for(let c=0;c<GRID;c++){
          const hue = ((r*GRID + c) * 16 + Math.floor(performance.now()/80)) % 360;
          ctx.fillStyle = `hsl(${hue},85%,55%)`;
          const x = bx + c*cell + 4, y = by + r*cell + 4;
          roundRectFill(x,y,cell-8,cell-8,6);
        }
      }
    }

    // draw animations
    anims.forEach(a=>{
      const p = Math.min((performance.now()-a.start)/a.dur,1);
      if(a.type==='row'){ const ry = by + a.index*cell + 4; const gx1 = bx + ( - (1-p) * (totalBoardPx) ); const gx2 = gx1 + totalBoardPx*1.2; const g = ctx.createLinearGradient(gx1, ry, gx2, ry + cell - 8); [0,0.14,0.28,0.42,0.56,0.7,0.86,1].forEach((s,i)=>{ const hue=(i*360/8 + p*360)%360; g.addColorStop(s, `hsla(${hue},90%,60%,${1-p})`); }); ctx.fillStyle=g; roundRectFill(bx+4, ry, totalBoardPx-8, cell-8,6); }
      if(a.type==='col'){ const cx = bx + a.index*cell + 4; const gy1 = by + ( - (1-p) * (totalBoardPx) ); const gy2 = gy1 + totalBoardPx*1.2; const g = ctx.createLinearGradient(cx, gy1, cx + cell - 8, gy2); [0,0.14,0.28,0.42,0.56,0.7,0.86,1].forEach((s,i)=>{ const hue=(i*360/8 + p*360)%360; g.addColorStop(s, `hsla(${hue},90%,60%,${1-p})`); }); ctx.fillStyle=g; roundRectFill(cx, by+4, cell-8, totalBoardPx-8,6); }
    });
    anims = anims.filter(a => (performance.now()-a.start) < a.dur);

    updateAndDrawParticles();

    // draw dragging preview if dragging
    if(dragging){
      // Compute where dragging would map to grid (using same mapping as canPlaceAt)
      const rect = canvas.getBoundingClientRect();
      const mx = (dragging.screenX - rect.left) * (canvas.width / rect.width);
      const my = (dragging.screenY - rect.top) * (canvas.height / rect.height);
      const col = Math.floor((mx/ (cell)) - (bx/cell));
      const row = Math.floor((my/ (cell)) - (by/cell));
      const valid = canPlaceAt(dragging.shape, row, col);
      if(typeof row === 'number' && typeof col === 'number'){
        for(let r=0;r<dragging.shape.length;r++){
          for(let c=0;c<dragging.shape[0].length;c++){
            if(dragging.shape[r][c]){
              const gx = bx + (col + c) * cell + 4;
              const gy = by + (row + r) * cell + 4;
              ctx.globalAlpha = valid ? 0.28 : 0.16;
              ctx.fillStyle = valid ? '#9ef6ff' : '#ff9e9e';
              roundRectFill(gx, gy, cell-8, cell-8, 6);
              ctx.globalAlpha = 1;
            }
          }
        }
      }
      // draw dragging piece near finger
      for(let r=0;r<dragging.shape.length;r++){
        for(let c=0;c<dragging.shape[0].length;c++){
          if(dragging.shape[r][c]){
            const size = Math.max(20, cell*0.9/2);
            const x = (dragging.screenX || 0) /  (window.devicePixelRatio||1) - (size/2) + c * (size+2);
            const y = (dragging.screenY || 0) /  (window.devicePixelRatio||1) - (size/2) + r * (size+2);
            ctx.fillStyle = dragging.color; ctx.fillRect(x,y,size,size);
          }
        }
      }
    }
  }

  // helper to draw rounded rect
  function roundRectFill(x,y,w,h,r){
    ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); ctx.fill();
  }

  // Placement check
  function canPlaceAt(shape,row,col){
    if(typeof row !== 'number' || typeof col !== 'number') return false;
    if(row === null || col === null) return false;
    for(let r=0;r<shape.length;r++){
      for(let c=0;c<shape[0].length;c++){
        if(shape[r][c]){
          const rr = row + r, cc = col + c;
          if(rr<0||cc<0||rr>=GRID||cc>=GRID) return false;
          if(grid[rr][cc]) return false;
        }
      }
    }
    return true;
  }

  // Place piece
  function placePieceAt(p,row,col){
    historyStack.push({grid:deepClone(grid),score,combo,fakeLossesRemaining});
    if(historyStack.length>6) historyStack.shift();

    const placedCells=[];
    for(let r=0;r<p.shape.length;r++){
      for(let c=0;c<p.shape[0].length;c++){
        if(p.shape[r][c]){
          const rr = row + r, cc = col + c;
          grid[rr][cc] = p.color;
          placedCells.push({r:rr,c:cc});
        }
      }
    }

    const cellsPlaced = placedCells.length;
    const basePts = cellsPlaced * 8;
    score += basePts;
    scoreEl.textContent = score;

    playPlace();

    // clear rows/cols
    const pre = deepClone(grid);
    const cleared = doClearLines();
    if(cleared.count>0){
      const spawnCells = [];
      cleared.rows.forEach(r=>{ for(let c=0;c<GRID;c++) spawnCells.push({r,c,color:pre[r][c]||'#fff'}); });
      cleared.cols.forEach(c=>{ for(let r=0;r<GRID;r++) spawnCells.push({r,c,color:pre[r][c]||'#fff'}); });
      spawnCells.forEach(sc=>spawnParticlesAtCell(sc.r,sc.c,sc.color));
      const now = performance.now();
      cleared.rows.forEach(r=>anims.push({type:'row',index:r,start:now,dur:900}));
      cleared.cols.forEach(c=>anims.push({type:'col',index:c,start:now,dur:900}));

      combo = Math.max(1, combo) + (Math.max(cleared.rows.length+cleared.cols.length,1)-1);
      const linesCount = Math.max(cleared.rows.length+cleared.cols.length,1);
      const pts = cleared.count * 12 * linesCount * combo;
      score += pts; scoreEl.textContent = score;
      playClear();
      showToast(`üî• Combo x${combo} +${pts} pts`,1400);
    } else {
      combo = 0;
    }

    saveHighIfNeeded();

    // refill pieces
    if(pieces.length === 0) generatePieces();
    else if(!hasAnyMoveForPieces(pieces)) handleNoMoves();
  }

  // Clear lines implementation
  function doClearLines(){
    const rowsCleared = [], colsCleared = [];
    for(let r=0;r<GRID;r++){
      if(grid[r].every(cell=>cell)) rowsCleared.push(r);
    }
    for(let c=0;c<GRID;c++){
      let full=true; for(let r=0;r<GRID;r++){ if(!grid[r][c]){ full=false; break; } } if(full) colsCleared.push(c);
    }
    const map={};
    rowsCleared.forEach(r=>{ for(let c=0;c<GRID;c++) map[`${r}_${c}`]=true; });
    colsCleared.forEach(c=>{ for(let r=0;r<GRID;r++) map[`${r}_${c}`]=true; });
    const keys = Object.keys(map);
    keys.forEach(k=>{ const [r,c] = k.split('_').map(Number); grid[r][c]=0; });
    return {rows:rowsCleared, cols:colsCleared, count: keys.length};
  }

  // Particles
  function spawnParticlesAtCell(r,c,color){
    const dpr = window.devicePixelRatio || 1;
    const canvasRect = canvas.getBoundingClientRect();
    const cellPx = (canvas.width / (GRID)) / dpr;
    const bx = (canvas.width / dpr - cellPx * GRID) / 2;
    const baseX = bx + c*cellPx + cellPx/2;
    const baseY = (canvas.height / dpr - cellPx * GRID) / 2 + r*cellPx + cellPx/2;
    const targetX = bx + cellPx * GRID + 40;
    const n = 6;
    for(let i=0;i<n;i++){
      particles.push({
        x: baseX, y: baseY,
        vx: (targetX - baseX)/40 + (Math.random()-0.5)*2,
        vy: (Math.random()-0.5)*2,
        born: performance.now(), life: 700 + Math.random()*400, color
      });
    }
    if(particles.length>800) particles.splice(0, particles.length-600);
  }
  function updateAndDrawParticles(){
    const now = performance.now();
    for(let i=particles.length-1;i>=0;i--){
      const p=particles[i]; const t=now-p.born;
      if(t>p.life){ particles.splice(i,1); continue; }
      p.x += p.vx; p.y += p.vy; const a = 1 - t/p.life;
      ctx.globalAlpha = a; ctx.fillStyle = p.color; ctx.fillRect(p.x-3,p.y-3,6,6); ctx.globalAlpha = 1;
    }
  }

  // Anim loop
  function loop(){
    draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // Checking possible placements for pieces (with rotations)
  function hasAnyMoveForPieces(checkPieces){
    for(const p of checkPieces){
      let s = deepClone(p.shape);
      for(let rot=0;rot<4;rot++){
        for(let r=0;r<GRID;r++){ for(let c=0;c<GRID;c++){ if(canPlaceAt(s,r,c)) return true; } }
        s = rotateMatrix(s);
      }
    }
    return false;
  }

  // Handle no moves -> fake loss
  function handleNoMoves(){
    fakeLossesRemaining--;
    localStorage.setItem('bb_fake_losses', String(fakeLossesRemaining));
    // update UI
    showToast(`‚ö†Ô∏è Kh√¥ng c√≤n n∆∞·ªõc ƒëi ‚Äî m·∫•t 1 l∆∞·ª£t. C√≤n ${fakeLossesRemaining}`, 1800);
    playFail();
    resetGrid();
    refillBag();
    generatePieces();
    if(fakeLossesRemaining > 0) continueBtn.style.display = 'block';
    else {
      showToast('üíÄ Thua th·∫≠t ‚Äî ƒêi·ªÉm v·ªÅ 0', 2200);
      score = 0; scoreEl.textContent = score;
      fakeLossesRemaining = 5; localStorage.setItem('bb_fake_losses', String(fakeLossesRemaining));
      continueBtn.style.display = 'none';
      saveHighIfNeeded();
    }
  }
  continueBtn.addEventListener('click', ()=>{
    continueBtn.style.display = 'none';
    showToast('Ti·∫øp t·ª•c ‚Äî ch∆°i ti·∫øp',1200);
  });

  // Render big slots (3) as big-slot elements with inner canvas previews
  function renderPiecesSlots(){
    piecesWrap.innerHTML = '';
    for(let i=0;i<3;i++){
      const slot = document.createElement('div'); slot.className = 'big-slot'; slot.dataset.index = i;
      const c = document.createElement('canvas'); c.width = 110; c.height = 110;
      c.style.width = '100%'; c.style.height = '100%';
      slot.appendChild(c);
      piecesWrap.appendChild(slot);

      // pointerdown to start dragging from big slot
      slot.addEventListener('pointerdown', (ev)=>{
        if(gameOver) return;
        if(audioCtx.state === 'suspended') audioCtx.resume();
        ev.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const p = pieces[i];
        // screen coords for finger tracking (we'll store the pointer's screen coords)
        dragging = { shape: deepClone(p.shape), color: p.color, spawnIndex:i, screenX: ev.clientX, screenY: ev.clientY };
        // remove piece from array (slot empties)
        pieces.splice(i,1);
        renderPiecesSlots();
      });

      // double click on slot rotates that piece clockwise
      slot.addEventListener('dblclick', (ev)=>{
        ev.stopPropagation();
        const idx = parseInt(slot.dataset.index,10);
        if(pieces[idx]){
          pieces[idx].shape = rotateMatrix(pieces[idx].shape);
          renderPiecesSlots();
        }
      });

      // draw piece preview into canvas
      const g = c.getContext('2d');
      g.clearRect(0,0,c.width,c.height);
      if(pieces[i]){
        const p = pieces[i];
        const smallCell = 18;
        const shapeW = p.shape[0].length * smallCell;
        const shapeH = p.shape.length * smallCell;
        const offsetX = Math.floor((c.width - shapeW)/2);
        const offsetY = Math.floor((c.height - shapeH)/2);
        for(let r=0;r<p.shape.length;r++){
          for(let cc0=0;cc0<p.shape[0].length;cc0++){
            if(p.shape[r][cc0]){
              g.fillStyle = p.color;
              g.fillRect(offsetX + cc0*smallCell + 4, offsetY + r*smallCell + 4, smallCell-6, smallCell-6);
            }
          }
        }
      }
    }
  }

  // pointermove global to track dragging finger and update dragging.screenX/screenY
  window.addEventListener('pointermove', (ev)=>{
    if(!dragging) return;
    dragging.screenX = ev.clientX;
    dragging.screenY = ev.clientY;
  });

  // pointerup -> attempt place
  window.addEventListener('pointerup', (ev)=>{
    if(!dragging) return;
    // compute grid coords relative to canvas
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    const mx = ev.clientX - rect.left;
    const my = ev.clientY - rect.top;
    // compute cell pixel size in client coords
    const clientCell = (rect.width) / GRID;
    const bx = 0;
    const col = Math.floor(mx / clientCell);
    const row = Math.floor(my / clientCell);
    if(canPlaceAt(dragging.shape, row, col)){
      placePieceAt(dragging, row, col);
      // refill if empty
      if(pieces.length === 0) generatePieces();
      else if(!hasAnyMoveForPieces(pieces)) handleNoMoves();
    } else {
      // animate return by restoring piece to pieces[] and show shake
      spawnShake();
      // restore piece back to pieces[] end
      pieces.push({ shape: deepClone(dragging.shape), color: dragging.color });
      renderPiecesSlots();
    }
    dragging = null;
  });

  // double-click on canvas while dragging rotates
  canvas.addEventListener('dblclick', (ev)=>{
    if(dragging){
      dragging.shape = rotateMatrix(dragging.shape);
      showToast('‚Üª Xoay kh·ªëi', 600);
    }
  });

  // animate shake (add small CSS class)
  function spawnShake(){ canvasWrap.classList.add('shake'); setTimeout(()=>canvasWrap.classList.remove('shake'),360); }

  // toast
  function showToast(text,dur=1400){
    const d = document.createElement('div'); d.className='toast'; d.textContent=text; toastWrap.appendChild(d);
    requestAnimationFrame(()=> d.classList.add('show'));
    setTimeout(()=> { d.classList.remove('show'); setTimeout(()=> d.remove(),300); }, dur);
  }

  // Undo (not shown in UI by default) - can add a button if desired

  // Controls
  resetBtn.addEventListener('click', ()=> resetAll());
  muteBtn.addEventListener('click', ()=>{
    isMuted = !isMuted;
    if(isMuted){ master.gain.setValueAtTime(0, audioCtx.currentTime); muteBtn.textContent='Muted'; }
    else { master.gain.setValueAtTime(1, audioCtx.currentTime); muteBtn.textContent='Sound'; }
  });

  // Highscore persistence
  function loadHigh(){ highScore = parseInt(localStorage.getItem('bb_high')||'0',10); if(isNaN(highScore)) highScore = 0; highEl.textContent = highScore; updateCrown(); }
  function saveHighIfNeeded(){ if(score > highScore){ highScore = score; localStorage.setItem('bb_high', String(highScore)); localStorage.setItem('bb_holder', localStorage.getItem('bb_name')||'Guest'); highEl.textContent = highScore; showToast('üèÜ New High Score!', 1600); updateCrown(); } }
  function updateCrown(){ const holder = localStorage.getItem('bb_holder') || ''; const name = localStorage.getItem('bb_name') || ''; crownEl.style.display = (score >= highScore && highScore>0) || (holder === name && highScore>0) ? 'inline' : 'none'; }

  // Name modal
  const nameModal = document.getElementById('nameModal');
  const nameInput = document.getElementById('nameInput');
  const nameSave = document.getElementById('nameSave');
  const skipName = document.getElementById('skipName');
  function askNameOnce(){ const stored = localStorage.getItem('bb_name'); if(stored){ playerNameEl.textContent = stored; return; } nameModal.classList.add('show'); }
  nameSave.addEventListener('click', ()=>{
    const v = nameInput.value.trim() || 'Guest';
    localStorage.setItem('bb_name', v);
    playerNameEl.textContent = v;
    nameModal.classList.remove('show');
  });
  skipName.addEventListener('click', ()=>{
    const v = 'Guest';
    localStorage.setItem('bb_name', v);
    playerNameEl.textContent = v;
    nameModal.classList.remove('show');
  });

  // Reset all / init
  function resetAll(){
    resetGrid();
    refillBag();
    generatePieces();
    score = 0; scoreEl.textContent = score;
    fakeLossesRemaining = 5; localStorage.setItem('bb_fake_losses', String(fakeLossesRemaining));
    combo = 0;
    historyStack = [];
    renderPiecesSlots();
    loadHigh();
    showToast('Game ƒë√£ ƒë∆∞·ª£c reset',900);
  }

  // Save highscore
  function saveHighIfNeeded(){ if(score > highScore){ highScore = score; localStorage.setItem('bb_high', String(highScore)); localStorage.setItem('bb_holder', localStorage.getItem('bb_name')||'Guest'); highEl.textContent = highScore; showToast('üèÜ New High Score!', 1600); updateCrown(); } }

  // Spawn pieces initial
  refillBag();
  generatePieces();
  loadHigh();
  askNameOnce();

  // Auto-play bg music on first interaction
  let musicStarted = false;
  function startAudioOnce(){
    if(!musicStarted){
      bgMusic.volume = 0.42;
      bgMusic.play().catch(()=>{});
      musicStarted = true;
    }
    if(audioCtx.state === 'suspended') audioCtx.resume().catch(()=>{});
  }
  window.addEventListener('pointerdown', startAudioOnce, {once:true});

  // Utility: has move for single piece
  function hasMoveForPiece(piece){ let s = deepClone(piece.shape); for(let rot=0;rot<4;rot++){ for(let r=0;r<GRID;r++) for(let c=0;c<GRID;c++) if(canPlaceAt(s,r,c)) return true; s = rotateMatrix(s); } return false; }

  // Render pieces into big slots initially
  renderPiecesSlots();

  // Expose debug on window
  window.BD = { grid, pieces, resetAll };

})();
</script>
</body>
</html>
